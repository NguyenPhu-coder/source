import pool from "../config/db.js";
import { ResultSetHeader, RowDataPacket } from "mysql2";

interface AutoQuizData extends RowDataPacket {
    id: number;
    user_id: number;
    course_id: number;
    title: string;
    description: string;
    passing_score: number;
    time_limit: number;
    questions_data: string; // JSON string of questions
    status: 'pending' | 'completed' | 'expired';
    score: number | null;
    passed: boolean | null;
    attempted_at: Date | null;
    created_at: Date;
}

export interface GeneratedQuestion {
    question: string;
    type: 'multiple_choice' | 'true_false' | 'fill_blank';
    options: string[];
    correct_answer: string | number;
    explanation: string;
    difficulty: string;
    bloom_level?: string;
}

export interface AutoQuizCreate {
    user_id: number;
    course_id: number;
    title: string;
    description?: string;
    passing_score?: number;
    time_limit?: number;
    questions: GeneratedQuestion[];
}

export const AutoGeneratedQuizModel = {
    // Create auto-generated quiz for user
    async create(data: AutoQuizCreate): Promise<number> {
        const [result] = await pool.query<ResultSetHeader>(
            `INSERT INTO auto_generated_quizzes 
       (user_id, course_id, title, description, passing_score, time_limit, questions_data, status) 
       VALUES (?, ?, ?, ?, ?, ?, ?, 'pending')`,
            [
                data.user_id,
                data.course_id,
                data.title,
                data.description || '',
                data.passing_score || 70,
                data.time_limit || 30,
                JSON.stringify(data.questions),
            ]
        );
        return result.insertId;
    },

    // Get pending quizzes for user
    async getPendingForUser(userId: number): Promise<AutoQuizData[]> {
        const [rows] = await pool.query<AutoQuizData[]>(
            `SELECT agq.*, c.title_en as course_title, c.title_vi as course_title_vi
       FROM auto_generated_quizzes agq
       JOIN courses c ON agq.course_id = c.id
       WHERE agq.user_id = ? AND agq.status = 'pending'
       ORDER BY agq.created_at DESC`,
            [userId]
        );
        return rows;
    },

    // Get all quizzes for user (with course info)
    async getAllForUser(userId: number): Promise<AutoQuizData[]> {
        const [rows] = await pool.query<AutoQuizData[]>(
            `SELECT agq.*, c.title_en as course_title, c.title_vi as course_title_vi
       FROM auto_generated_quizzes agq
       JOIN courses c ON agq.course_id = c.id
       WHERE agq.user_id = ?
       ORDER BY agq.created_at DESC`,
            [userId]
        );
        return rows;
    },

    // Get quiz by ID
    async getById(quizId: number, userId?: number): Promise<AutoQuizData | null> {
        let query = `SELECT agq.*, c.title_en as course_title, c.title_vi as course_title_vi
                 FROM auto_generated_quizzes agq
                 JOIN courses c ON agq.course_id = c.id
                 WHERE agq.id = ?`;
        const params: any[] = [quizId];

        if (userId) {
            query += ' AND agq.user_id = ?';
            params.push(userId);
        }

        const [rows] = await pool.query<AutoQuizData[]>(query, params);
        return rows.length > 0 ? rows[0] : null;
    },

    // Check if quiz exists for user and course
    async existsForUserCourse(userId: number, courseId: number): Promise<boolean> {
        const [rows] = await pool.query<RowDataPacket[]>(
            `SELECT id FROM auto_generated_quizzes 
       WHERE user_id = ? AND course_id = ? AND status = 'pending'
       LIMIT 1`,
            [userId, courseId]
        );
        return rows.length > 0;
    },

    // Submit quiz attempt
    async submitAttempt(
        quizId: number,
        userId: number,
        answers: { questionIndex: number; answer: string | number }[]
    ): Promise<{ score: number; passed: boolean; results: any[] }> {
        const quiz = await this.getById(quizId, userId);
        if (!quiz) {
            throw new Error('Quiz not found');
        }

        const questions: GeneratedQuestion[] = JSON.parse(quiz.questions_data);
        let correctCount = 0;
        const results: any[] = [];

        for (const answer of answers) {
            const question = questions[answer.questionIndex];
            if (!question) continue;

            let isCorrect = false;
            if (typeof question.correct_answer === 'number') {
                isCorrect = answer.answer === question.correct_answer;
            } else {
                isCorrect = String(answer.answer).toLowerCase().trim() ===
                    String(question.correct_answer).toLowerCase().trim();
            }

            if (isCorrect) correctCount++;

            results.push({
                questionIndex: answer.questionIndex,
                userAnswer: answer.answer,
                correctAnswer: question.correct_answer,
                isCorrect,
                explanation: question.explanation,
            });
        }

        const score = Math.round((correctCount / questions.length) * 100);
        const passed = score >= quiz.passing_score;

        // Update quiz status
        await pool.query(
            `UPDATE auto_generated_quizzes 
       SET status = 'completed', score = ?, passed = ?, attempted_at = NOW()
       WHERE id = ? AND user_id = ?`,
            [score, passed, quizId, userId]
        );

        return { score, passed, results };
    },

    // Get quiz statistics for user
    async getStats(userId: number): Promise<{
        total: number;
        completed: number;
        pending: number;
        avgScore: number;
        passRate: number;
    }> {
        const [stats] = await pool.query<RowDataPacket[]>(
            `SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
        AVG(CASE WHEN status = 'completed' THEN score ELSE NULL END) as avg_score,
        SUM(CASE WHEN passed = 1 THEN 1 ELSE 0 END) as passed_count
       FROM auto_generated_quizzes
       WHERE user_id = ?`,
            [userId]
        );

        const row = stats[0];
        return {
            total: row.total || 0,
            completed: row.completed || 0,
            pending: row.pending || 0,
            avgScore: Math.round(row.avg_score || 0),
            passRate: row.completed > 0 ? Math.round((row.passed_count / row.completed) * 100) : 0,
        };
    },
};
